# Generated by ruleopt/generate.py, don't edit!

import sys
from rpython.jit.metainterp.history import ConstInt
from rpython.jit.metainterp.optimizeopt.util import (
    get_box_replacement)
from rpython.jit.metainterp.resoperation import rop

from rpython.rlib.rarithmetic import LONG_BIT, r_uint, intmask, ovfcheck, uint_mul_high, highest_bit
MAXINT = sys.maxint
MININT = -sys.maxint - 1


class OptIntAutoGenerated(object):
    def _eq(self, box1, bound1, box2, bound2):
        if box1 is box2: return True
        if bound1.is_constant() and bound2.is_constant() and bound1.lower == bound2.lower: return True
        return False
    _all_rules_fired = []
    _rule_names_int_mul = ['mul_zero', 'mul_one', 'mul_minus_one', 'mul_pow2_const', 'mul_lshift']
    _rule_fired_int_mul = [0] * 5
    _all_rules_fired.append(('int_mul', _rule_names_int_mul, _rule_fired_int_mul))
    def optimize_INT_MUL(self, op):
        arg_0 = get_box_replacement(op.getarg(0))
        b_arg_0 = self.getintbound(arg_0)
        arg_1 = get_box_replacement(op.getarg(1))
        b_arg_1 = self.getintbound(arg_1)
        if b_arg_0.is_constant():
            C_arg_0 = b_arg_0.get_constant_int()
            # mul_zero: int_mul(0, x) => 0
            if C_arg_0 == 0:
                self.make_constant_int(op, 0)
                self._rule_fired_int_mul[0] += 1
                return
        if b_arg_1.is_constant():
            C_arg_1 = b_arg_1.get_constant_int()
            # mul_zero: int_mul(x, 0) => 0
            if C_arg_1 == 0:
                self.make_constant_int(op, 0)
                self._rule_fired_int_mul[0] += 1
                return
        if b_arg_0.is_constant():
            C_arg_0 = b_arg_0.get_constant_int()
            # mul_one: int_mul(1, x) => x
            if C_arg_0 == 1:
                self.make_equal_to(op, arg_1)
                self._rule_fired_int_mul[1] += 1
                return
        if b_arg_1.is_constant():
            C_arg_1 = b_arg_1.get_constant_int()
            # mul_one: int_mul(x, 1) => x
            if C_arg_1 == 1:
                self.make_equal_to(op, arg_0)
                self._rule_fired_int_mul[1] += 1
                return
        if b_arg_0.is_constant():
            C_arg_0 = b_arg_0.get_constant_int()
            # mul_minus_one: int_mul(-1, x) => int_neg(x)
            if C_arg_0 == -1:
                newop = self.replace_op_with(op, rop.INT_NEG, args=[arg_1])
                self.optimizer.send_extra_operation(newop)
                self._rule_fired_int_mul[2] += 1
                return
            # mul_pow2_const: int_mul(C, x) => int_lshift(x, shift)
            if C_arg_0 > 0 and C_arg_0 & intmask(r_uint(C_arg_0) - r_uint(1)) == 0:
                shift = highest_bit(C_arg_0)
                newop = self.replace_op_with(op, rop.INT_LSHIFT, args=[arg_1, ConstInt(shift)])
                self.optimizer.send_extra_operation(newop)
                self._rule_fired_int_mul[3] += 1
                return
        else:
            arg_0_int_lshift = self.optimizer.as_operation(arg_0, rop.INT_LSHIFT)
            if arg_0_int_lshift is not None:
                arg_0_0 = get_box_replacement(arg_0_int_lshift.getarg(0))
                b_arg_0_0 = self.getintbound(arg_0_0)
                arg_0_1 = get_box_replacement(arg_0_int_lshift.getarg(1))
                b_arg_0_1 = self.getintbound(arg_0_1)
                if b_arg_0_0.is_constant():
                    C_arg_0_0 = b_arg_0_0.get_constant_int()
                    # mul_lshift: int_mul(int_lshift(1, y), x) => int_lshift(x, y)
                    if C_arg_0_0 == 1:
                        if b_arg_0_1.known_ge_const(0) and b_arg_0_1.known_le_const(LONG_BIT):
                            newop = self.replace_op_with(op, rop.INT_LSHIFT, args=[arg_1, arg_0_1])
                            self.optimizer.send_extra_operation(newop)
                            self._rule_fired_int_mul[4] += 1
                            return
        if b_arg_1.is_constant():
            C_arg_1 = b_arg_1.get_constant_int()
            # mul_minus_one: int_mul(x, -1) => int_neg(x)
            if C_arg_1 == -1:
                newop = self.replace_op_with(op, rop.INT_NEG, args=[arg_0])
                self.optimizer.send_extra_operation(newop)
                self._rule_fired_int_mul[2] += 1
                return
            # mul_pow2_const: int_mul(x, C) => int_lshift(x, shift)
            if C_arg_1 > 0 and C_arg_1 & intmask(r_uint(C_arg_1) - r_uint(1)) == 0:
                shift = highest_bit(C_arg_1)
                newop = self.replace_op_with(op, rop.INT_LSHIFT, args=[arg_0, ConstInt(shift)])
                self.optimizer.send_extra_operation(newop)
                self._rule_fired_int_mul[3] += 1
                return
        else:
            arg_1_int_lshift = self.optimizer.as_operation(arg_1, rop.INT_LSHIFT)
            if arg_1_int_lshift is not None:
                arg_1_0 = get_box_replacement(arg_1_int_lshift.getarg(0))
                b_arg_1_0 = self.getintbound(arg_1_0)
                arg_1_1 = get_box_replacement(arg_1_int_lshift.getarg(1))
                b_arg_1_1 = self.getintbound(arg_1_1)
                if b_arg_1_0.is_constant():
                    C_arg_1_0 = b_arg_1_0.get_constant_int()
                    # mul_lshift: int_mul(x, int_lshift(1, y)) => int_lshift(x, y)
                    if C_arg_1_0 == 1:
                        if b_arg_1_1.known_ge_const(0) and b_arg_1_1.known_le_const(LONG_BIT):
                            newop = self.replace_op_with(op, rop.INT_LSHIFT, args=[arg_0, arg_1_1])
                            self.optimizer.send_extra_operation(newop)
                            self._rule_fired_int_mul[4] += 1
                            return
        return self.emit(op)
    _rule_names_int_lshift = ['lshift_zero_x', 'lshift_x_zero', 'lshift_rshift_c_c', 'lshift_and_rshift', 'lshift_urshift_c_c', 'lshift_and_urshift', 'lshift_lshift_c_c']
    _rule_fired_int_lshift = [0] * 7
    _all_rules_fired.append(('int_lshift', _rule_names_int_lshift, _rule_fired_int_lshift))
    def optimize_INT_LSHIFT(self, op):
        arg_0 = get_box_replacement(op.getarg(0))
        b_arg_0 = self.getintbound(arg_0)
        arg_1 = get_box_replacement(op.getarg(1))
        b_arg_1 = self.getintbound(arg_1)
        if b_arg_0.is_constant():
            C_arg_0 = b_arg_0.get_constant_int()
            # lshift_zero_x: int_lshift(0, x) => 0
            if C_arg_0 == 0:
                self.make_constant_int(op, 0)
                self._rule_fired_int_lshift[0] += 1
                return
        if b_arg_1.is_constant():
            C_arg_1 = b_arg_1.get_constant_int()
            # lshift_x_zero: int_lshift(x, 0) => x
            if C_arg_1 == 0:
                self.make_equal_to(op, arg_0)
                self._rule_fired_int_lshift[1] += 1
                return
        arg_0_int_and = self.optimizer.as_operation(arg_0, rop.INT_AND)
        if arg_0_int_and is not None:
            arg_0_0 = get_box_replacement(arg_0_int_and.getarg(0))
            b_arg_0_0 = self.getintbound(arg_0_0)
            arg_0_1 = get_box_replacement(arg_0_int_and.getarg(1))
            b_arg_0_1 = self.getintbound(arg_0_1)
            if b_arg_0_0.is_constant():
                C_arg_0_0 = b_arg_0_0.get_constant_int()
                arg_0_1_int_rshift = self.optimizer.as_operation(arg_0_1, rop.INT_RSHIFT)
                if arg_0_1_int_rshift is not None:
                    arg_0_1_0 = get_box_replacement(arg_0_1_int_rshift.getarg(0))
                    b_arg_0_1_0 = self.getintbound(arg_0_1_0)
                    arg_0_1_1 = get_box_replacement(arg_0_1_int_rshift.getarg(1))
                    b_arg_0_1_1 = self.getintbound(arg_0_1_1)
                    if b_arg_0_1_1.is_constant():
                        C_arg_0_1_1 = b_arg_0_1_1.get_constant_int()
                        if b_arg_1.is_constant():
                            C_arg_1 = b_arg_1.get_constant_int()
                            # lshift_and_rshift: int_lshift(int_and(C2, int_rshift(x, C1)), C1) => int_and(x, C)
                            if C_arg_1 == C_arg_0_1_1:
                                if 0 <= C_arg_0_1_1 and C_arg_0_1_1 < LONG_BIT:
                                    C = C_arg_0_0 << C_arg_0_1_1
                                    newop = self.replace_op_with(op, rop.INT_AND, args=[arg_0_1_0, ConstInt(C)])
                                    self.optimizer.send_extra_operation(newop)
                                    self._rule_fired_int_lshift[3] += 1
                                    return
                else:
                    arg_0_1_uint_rshift = self.optimizer.as_operation(arg_0_1, rop.UINT_RSHIFT)
                    if arg_0_1_uint_rshift is not None:
                        arg_0_1_0 = get_box_replacement(arg_0_1_uint_rshift.getarg(0))
                        b_arg_0_1_0 = self.getintbound(arg_0_1_0)
                        arg_0_1_1 = get_box_replacement(arg_0_1_uint_rshift.getarg(1))
                        b_arg_0_1_1 = self.getintbound(arg_0_1_1)
                        if b_arg_0_1_1.is_constant():
                            C_arg_0_1_1 = b_arg_0_1_1.get_constant_int()
                            if b_arg_1.is_constant():
                                C_arg_1 = b_arg_1.get_constant_int()
                                # lshift_and_urshift: int_lshift(int_and(C2, uint_rshift(x, C1)), C1) => int_and(x, C)
                                if C_arg_1 == C_arg_0_1_1:
                                    if 0 <= C_arg_0_1_1 and C_arg_0_1_1 < LONG_BIT:
                                        C = C_arg_0_0 << C_arg_0_1_1
                                        newop = self.replace_op_with(op, rop.INT_AND, args=[arg_0_1_0, ConstInt(C)])
                                        self.optimizer.send_extra_operation(newop)
                                        self._rule_fired_int_lshift[5] += 1
                                        return
            else:
                arg_0_0_int_rshift = self.optimizer.as_operation(arg_0_0, rop.INT_RSHIFT)
                if arg_0_0_int_rshift is not None:
                    arg_0_0_0 = get_box_replacement(arg_0_0_int_rshift.getarg(0))
                    b_arg_0_0_0 = self.getintbound(arg_0_0_0)
                    arg_0_0_1 = get_box_replacement(arg_0_0_int_rshift.getarg(1))
                    b_arg_0_0_1 = self.getintbound(arg_0_0_1)
                    if b_arg_0_0_1.is_constant():
                        C_arg_0_0_1 = b_arg_0_0_1.get_constant_int()
                        if b_arg_0_1.is_constant():
                            C_arg_0_1 = b_arg_0_1.get_constant_int()
                            if b_arg_1.is_constant():
                                C_arg_1 = b_arg_1.get_constant_int()
                                # lshift_and_rshift: int_lshift(int_and(int_rshift(x, C1), C2), C1) => int_and(x, C)
                                if C_arg_1 == C_arg_0_0_1:
                                    if 0 <= C_arg_0_0_1 and C_arg_0_0_1 < LONG_BIT:
                                        C = C_arg_0_1 << C_arg_0_0_1
                                        newop = self.replace_op_with(op, rop.INT_AND, args=[arg_0_0_0, ConstInt(C)])
                                        self.optimizer.send_extra_operation(newop)
                                        self._rule_fired_int_lshift[3] += 1
                                        return
                else:
                    arg_0_0_uint_rshift = self.optimizer.as_operation(arg_0_0, rop.UINT_RSHIFT)
                    if arg_0_0_uint_rshift is not None:
                        arg_0_0_0 = get_box_replacement(arg_0_0_uint_rshift.getarg(0))
                        b_arg_0_0_0 = self.getintbound(arg_0_0_0)
                        arg_0_0_1 = get_box_replacement(arg_0_0_uint_rshift.getarg(1))
                        b_arg_0_0_1 = self.getintbound(arg_0_0_1)
                        if b_arg_0_0_1.is_constant():
                            C_arg_0_0_1 = b_arg_0_0_1.get_constant_int()
                            if b_arg_0_1.is_constant():
                                C_arg_0_1 = b_arg_0_1.get_constant_int()
                                if b_arg_1.is_constant():
                                    C_arg_1 = b_arg_1.get_constant_int()
                                    # lshift_and_urshift: int_lshift(int_and(uint_rshift(x, C1), C2), C1) => int_and(x, C)
                                    if C_arg_1 == C_arg_0_0_1:
                                        if 0 <= C_arg_0_0_1 and C_arg_0_0_1 < LONG_BIT:
                                            C = C_arg_0_1 << C_arg_0_0_1
                                            newop = self.replace_op_with(op, rop.INT_AND, args=[arg_0_0_0, ConstInt(C)])
                                            self.optimizer.send_extra_operation(newop)
                                            self._rule_fired_int_lshift[5] += 1
                                            return
        else:
            arg_0_int_lshift = self.optimizer.as_operation(arg_0, rop.INT_LSHIFT)
            if arg_0_int_lshift is not None:
                arg_0_0 = get_box_replacement(arg_0_int_lshift.getarg(0))
                b_arg_0_0 = self.getintbound(arg_0_0)
                arg_0_1 = get_box_replacement(arg_0_int_lshift.getarg(1))
                b_arg_0_1 = self.getintbound(arg_0_1)
                if b_arg_0_1.is_constant():
                    C_arg_0_1 = b_arg_0_1.get_constant_int()
                    if b_arg_1.is_constant():
                        C_arg_1 = b_arg_1.get_constant_int()
                        # lshift_lshift_c_c: int_lshift(int_lshift(x, C1), C2) => int_lshift(x, C)
                        if 0 <= C_arg_0_1 and C_arg_0_1 < LONG_BIT and 0 <= C_arg_1 and C_arg_1 < LONG_BIT:
                            C = intmask(r_uint(C_arg_0_1) + r_uint(C_arg_1))
                            if C < LONG_BIT:
                                newop = self.replace_op_with(op, rop.INT_LSHIFT, args=[arg_0_0, ConstInt(C)])
                                self.optimizer.send_extra_operation(newop)
                                self._rule_fired_int_lshift[6] += 1
                                return
            else:
                arg_0_int_rshift = self.optimizer.as_operation(arg_0, rop.INT_RSHIFT)
                if arg_0_int_rshift is not None:
                    arg_0_0 = get_box_replacement(arg_0_int_rshift.getarg(0))
                    b_arg_0_0 = self.getintbound(arg_0_0)
                    arg_0_1 = get_box_replacement(arg_0_int_rshift.getarg(1))
                    b_arg_0_1 = self.getintbound(arg_0_1)
                    if b_arg_0_1.is_constant():
                        C_arg_0_1 = b_arg_0_1.get_constant_int()
                        if b_arg_1.is_constant():
                            C_arg_1 = b_arg_1.get_constant_int()
                            # lshift_rshift_c_c: int_lshift(int_rshift(x, C1), C1) => int_and(x, C)
                            if C_arg_1 == C_arg_0_1:
                                if 0 <= C_arg_0_1 and C_arg_0_1 < LONG_BIT:
                                    C = -1 << C_arg_0_1
                                    newop = self.replace_op_with(op, rop.INT_AND, args=[arg_0_0, ConstInt(C)])
                                    self.optimizer.send_extra_operation(newop)
                                    self._rule_fired_int_lshift[2] += 1
                                    return
                else:
                    arg_0_uint_rshift = self.optimizer.as_operation(arg_0, rop.UINT_RSHIFT)
                    if arg_0_uint_rshift is not None:
                        arg_0_0 = get_box_replacement(arg_0_uint_rshift.getarg(0))
                        b_arg_0_0 = self.getintbound(arg_0_0)
                        arg_0_1 = get_box_replacement(arg_0_uint_rshift.getarg(1))
                        b_arg_0_1 = self.getintbound(arg_0_1)
                        if b_arg_0_1.is_constant():
                            C_arg_0_1 = b_arg_0_1.get_constant_int()
                            if b_arg_1.is_constant():
                                C_arg_1 = b_arg_1.get_constant_int()
                                # lshift_urshift_c_c: int_lshift(uint_rshift(x, C1), C1) => int_and(x, C)
                                if C_arg_1 == C_arg_0_1:
                                    if 0 <= C_arg_0_1 and C_arg_0_1 < LONG_BIT:
                                        C = -1 << C_arg_0_1
                                        newop = self.replace_op_with(op, rop.INT_AND, args=[arg_0_0, ConstInt(C)])
                                        self.optimizer.send_extra_operation(newop)
                                        self._rule_fired_int_lshift[4] += 1
                                        return
        return self.emit(op)